set -ex

nsc docker login --output_registry_to /tmp/registry
REGISTRY=`cat /tmp/registry`

#nsc create --bare --features EXP_DOCKER_CONTAINERD_STORE --experimental_from prewarm.json
nsc create --bare -o json > cluster.json

# Get the cluster ID from the creation output.
CLUSTER_ID=`jq -r .cluster_id < cluster.json`
# Get the region ingress domain too.
INGRESS_DOMAIN=`jq -r .ingress_domain < cluster.json`
# Compute a docker context to use.
DOCKER_CONTEXT=nsc-$CLUSTER_ID
# Set the predictable backend name.
BACKEND_INGRESS_NAME=backend
# Compute the resulting backend URL.
BACKEND_URL="${BACKEND_INGRESS_NAME}-${CLUSTER_ID}.${INGRESS_DOMAIN}"
# Use a stable tag to ensure that we deploy what we build (ideally would be the commit hash).
TAG=xyz

# Create a separate docker context to ensure that we can change `buildx`'s builder.
nsc docker attach-context --name $DOCKER_CONTEXT --to $CLUSTER_ID --background

# Setup the remote builder (for caching across runs).
nsc docker buildx setup --background --create_at_startup --name nsc-remote

# Tell buildx to use the remote builder ("nsc-remote").
docker -c $DOCKER_CONTEXT buildx use nsc-remote

# Build backend and frontend in parallel (and pass in REGISTRY, BACKEND_URL and TAG)
REGISTRY=$REGISTRY BACKEND_URL=$BACKEND_URL TAG=$TAG docker -c $DOCKER_CONTEXT buildx bake --push

# Bring up the dependencies.
docker -c $DOCKER_CONTEXT compose up -d

# Expose the backend's ingress (the container name is generated by compose)
nsc expose $CLUSTER_ID --ingress '*=noauth' --container compose-demo-backend-1 --name $BACKEND_INGRESS_NAME

# Start the frontend in the same cluster, alongside the other containers.
docker -c $DOCKER_CONTEXT run -d --name frontend -p 3000:3000 $REGISTRY/frontend:$TAG

# Expose the frontend to the internet.
nsc expose $CLUSTER_ID --container frontend
